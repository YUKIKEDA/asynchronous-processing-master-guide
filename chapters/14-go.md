# ç¬¬14ç« : Go

> ğŸ¯ **ã“ã®ç« ã®ç›®æ¨™**: Goã®Goroutineã€ãƒãƒ£ãƒãƒ«ã€selectæ–‡ã€M:Nã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã‚’ç†è§£ã—ã€Goã®ä¸¦è¡Œå‡¦ç†ãƒ¢ãƒ‡ãƒ«ã‚’ãƒã‚¹ã‚¿ãƒ¼ã™ã‚‹

---

## 14.1 Goã®ä¸¦è¡Œå‡¦ç†ã®å“²å­¦

### ã€Œå…±æœ‰ãƒ¡ãƒ¢ãƒªã§é€šä¿¡ã™ã‚‹ãªã€é€šä¿¡ã§ãƒ¡ãƒ¢ãƒªã‚’å…±æœ‰ã›ã‚ˆã€

Goã®ä¸¦è¡Œå‡¦ç†ã®è¨­è¨ˆå“²å­¦ã¯ã€ã“ã®ã‚¹ãƒ­ãƒ¼ã‚¬ãƒ³ã«é›†ç´„ã•ã‚Œã¾ã™ã€‚å…±æœ‰ãƒ¡ãƒ¢ãƒªã¨ãƒ­ãƒƒã‚¯ã®ä»£ã‚ã‚Šã«ã€ãƒãƒ£ãƒãƒ«ã‚’ä½¿ã£ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ‘ãƒƒã‚·ãƒ³ã‚°ã‚’æ¨å¥¨ã—ã¦ã„ã¾ã™ã€‚

```mermaid
flowchart TB
    subgraph PHILOSOPHY["Goã®ä¸¦è¡Œå‡¦ç†å“²å­¦"]
        subgraph BAD["âŒ å…±æœ‰ãƒ¡ãƒ¢ãƒªã§é€šä¿¡"]
            MEM["å…±æœ‰ãƒ¡ãƒ¢ãƒª"]
            T1_BAD["Goroutine 1"]
            T2_BAD["Goroutine 2"]
            LOCK["ãƒ­ãƒƒã‚¯"]
            
            T1_BAD <-->|"èª­ã¿æ›¸ã"| MEM
            T2_BAD <-->|"èª­ã¿æ›¸ã"| MEM
            MEM --- LOCK
        end
        
        subgraph GOOD["âœ… é€šä¿¡ã§ãƒ¡ãƒ¢ãƒªã‚’å…±æœ‰"]
            CH["ãƒãƒ£ãƒãƒ«"]
            T1_GOOD["Goroutine 1"]
            T2_GOOD["Goroutine 2"]
            
            T1_GOOD -->|"é€ä¿¡"| CH
            CH -->|"å—ä¿¡"| T2_GOOD
        end
    end
```

### CSPï¼ˆCommunicating Sequential Processesï¼‰

Goã¯Tony Hoareã®CSPç†è«–ã«åŸºã¥ã„ã¦ã„ã¾ã™ã€‚ç¬¬10ç« ã§å­¦ã‚“ã CSPã®å®Ÿè·µçš„ãªå®Ÿè£…ãŒGoã§ã™ã€‚

```mermaid
flowchart LR
    subgraph CSP_MODEL["CSPãƒ¢ãƒ‡ãƒ«ã®å®Ÿè£…"]
        PROCESS["ãƒ—ãƒ­ã‚»ã‚¹<br/>â†’ Goroutine"]
        CHANNEL["ãƒãƒ£ãƒãƒ«<br/>â†’ chan"]
        SYNC["åŒæœŸé€šä¿¡<br/>â†’ é€å—ä¿¡"]
    end
    
    PROCESS --> CHANNEL --> SYNC
```

---

## 14.2 Goroutine

### Goroutineã¨ã¯

**Goroutine**ã¯ã€Goãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã«ã‚ˆã£ã¦ç®¡ç†ã•ã‚Œã‚‹è»½é‡ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã™ã€‚OSã‚¹ãƒ¬ãƒƒãƒ‰ã‚ˆã‚Šã‚‚è»½é‡ã§ã€æ•°åƒã€œæ•°ç™¾ä¸‡ã®goroutineã‚’åŒæ™‚ã«å®Ÿè¡Œã§ãã¾ã™ã€‚

```mermaid
flowchart TB
    subgraph GOROUTINE_CONCEPT["Goroutineã®ç‰¹å¾´"]
        G1["è»½é‡<br/>åˆæœŸã‚¹ã‚¿ãƒƒã‚¯ 2KB"]
        G2["å¤šæ•°åŒæ™‚å®Ÿè¡Œ<br/>æ•°ç™¾ä¸‡ã‚‚å¯èƒ½"]
        G3["M:N ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°<br/>ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãŒç®¡ç†"]
        G4["å”èª¿çš„ãƒ—ãƒªã‚¨ãƒ³ãƒ—ã‚·ãƒ§ãƒ³<br/>è‡ªå‹•çš„ã«åˆ‡ã‚Šæ›¿ãˆ"]
    end
```

### åŸºæœ¬çš„ãªä½¿ã„æ–¹

```go
package main

import (
    "fmt"
    "time"
)

func sayHello(name string) {
    for i := 0; i < 3; i++ {
        fmt.Printf("Hello, %s! (%d)\n", name, i)
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    // go ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§ goroutine ã‚’èµ·å‹•
    go sayHello("World")
    go sayHello("Go")
    
    // ãƒ¡ã‚¤ãƒ³ goroutine ã®å‡¦ç†
    fmt.Println("Main goroutine")
    
    // goroutine ã®å®Œäº†ã‚’å¾…ã¤ï¼ˆç°¡æ˜“çš„ãªæ–¹æ³•ï¼‰
    time.Sleep(500 * time.Millisecond)
    fmt.Println("Done")
}
```

### ç„¡åé–¢æ•°ã§ã®Goroutine

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // ç„¡åé–¢æ•°ã‚’ goroutine ã§å®Ÿè¡Œ
    go func() {
        fmt.Println("Anonymous goroutine")
    }()
    
    // å¼•æ•°ã‚’æ¸¡ã™å ´åˆ
    message := "Hello"
    go func(msg string) {
        fmt.Println(msg)
    }(message)  // å¼•æ•°ã‚’æ¸¡ã™
    
    // ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã®æ³¨æ„ç‚¹
    for i := 0; i < 3; i++ {
        // NG: i ã‚’ç›´æ¥å‚ç…§ã™ã‚‹ã¨æœ€çµ‚å€¤ã«ãªã‚ŠãŒã¡
        // go func() {
        //     fmt.Println(i)  // 3, 3, 3 ã«ãªã‚‹å¯èƒ½æ€§
        // }()
        
        // OK: å¼•æ•°ã¨ã—ã¦æ¸¡ã™
        go func(n int) {
            fmt.Println(n)  // 0, 1, 2
        }(i)
    }
    
    time.Sleep(100 * time.Millisecond)
}
```

### Goroutineã®ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«

```mermaid
sequenceDiagram
    participant Main as main()
    participant G1 as Goroutine 1
    participant G2 as Goroutine 2
    participant Runtime as ãƒ©ãƒ³ã‚¿ã‚¤ãƒ 
    
    Main->>Runtime: go func1()
    Runtime->>G1: èµ·å‹•
    Main->>Runtime: go func2()
    Runtime->>G2: èµ·å‹•
    
    par ä¸¦è¡Œå®Ÿè¡Œ
        G1->>G1: å‡¦ç†
        G2->>G2: å‡¦ç†
        Main->>Main: å‡¦ç†
    end
    
    G1-->>Runtime: å®Œäº†
    G2-->>Runtime: å®Œäº†
    
    Note over Main: main() ãŒçµ‚äº†ã™ã‚‹ã¨<br/>ã™ã¹ã¦ã® goroutine ãŒå¼·åˆ¶çµ‚äº†
```

### WaitGroupã«ã‚ˆã‚‹åŒæœŸ

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()  // å®Œäº†ã‚’é€šçŸ¥
    
    fmt.Printf("Worker %d: é–‹å§‹\n", id)
    time.Sleep(time.Second)
    fmt.Printf("Worker %d: å®Œäº†\n", id)
}

func main() {
    var wg sync.WaitGroup
    
    for i := 1; i <= 3; i++ {
        wg.Add(1)  // ã‚«ã‚¦ãƒ³ã‚¿ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
        go worker(i, &wg)
    }
    
    wg.Wait()  // ã™ã¹ã¦ã® goroutine ãŒå®Œäº†ã™ã‚‹ã¾ã§å¾…æ©Ÿ
    fmt.Println("ã™ã¹ã¦ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ãŒå®Œäº†")
}
```

```mermaid
flowchart TB
    subgraph WAITGROUP["WaitGroupã®å‹•ä½œ"]
        ADD["wg.Add(n)<br/>ã‚«ã‚¦ãƒ³ã‚¿ += n"]
        DONE["wg.Done()<br/>ã‚«ã‚¦ãƒ³ã‚¿ -= 1"]
        WAIT["wg.Wait()<br/>ã‚«ã‚¦ãƒ³ã‚¿ == 0 ã¾ã§å¾…æ©Ÿ"]
    end
    
    ADD --> DONE
    DONE --> WAIT
```

---

## 14.3 ãƒãƒ£ãƒãƒ«ï¼ˆChannelï¼‰

### ãƒãƒ£ãƒãƒ«ã¨ã¯

**ãƒãƒ£ãƒãƒ«**ã¯ã€goroutineé–“ã§ãƒ‡ãƒ¼ã‚¿ã‚’å®‰å…¨ã«é€å—ä¿¡ã™ã‚‹ãŸã‚ã®é€šä¿¡æ©Ÿæ§‹ã§ã™ã€‚å‹ä»˜ã‘ã•ã‚Œã¦ãŠã‚Šã€ç‰¹å®šã®å‹ã®ãƒ‡ãƒ¼ã‚¿ã®ã¿ã‚’é€å—ä¿¡ã§ãã¾ã™ã€‚

```go
package main

import "fmt"

func main() {
    // ãƒãƒ£ãƒãƒ«ã®ä½œæˆ
    ch := make(chan int)  // int å‹ã®ãƒãƒ£ãƒãƒ«
    
    // goroutine ã§é€ä¿¡
    go func() {
        ch <- 42  // é€ä¿¡
    }()
    
    // ãƒ¡ã‚¤ãƒ³ã§å—ä¿¡
    value := <-ch  // å—ä¿¡
    fmt.Println(value)  // 42
}
```

### ãƒãƒ£ãƒãƒ«ã®é€å—ä¿¡

```mermaid
flowchart LR
    subgraph CHANNEL_OPS["ãƒãƒ£ãƒãƒ«æ“ä½œ"]
        SEND["ch <- value<br/>é€ä¿¡"]
        CH["ãƒãƒ£ãƒãƒ«"]
        RECV["value := <-ch<br/>å—ä¿¡"]
    end
    
    SEND --> CH --> RECV
```

```go
package main

import "fmt"

func main() {
    ch := make(chan string)
    
    go func() {
        ch <- "Hello"
        ch <- "World"
        close(ch)  // ãƒãƒ£ãƒãƒ«ã‚’é–‰ã˜ã‚‹
    }()
    
    // æ–¹æ³•1: æ˜ç¤ºçš„ãªå—ä¿¡
    msg1 := <-ch
    msg2 := <-ch
    fmt.Println(msg1, msg2)
    
    // æ–¹æ³•2: range ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ãƒˆ
    ch2 := make(chan int)
    go func() {
        for i := 0; i < 5; i++ {
            ch2 <- i
        }
        close(ch2)
    }()
    
    for value := range ch2 {
        fmt.Println(value)
    }
}
```

### ãƒãƒƒãƒ•ã‚¡ãªã—ãƒãƒ£ãƒãƒ«ï¼ˆåŒæœŸãƒãƒ£ãƒãƒ«ï¼‰

ãƒãƒƒãƒ•ã‚¡ãªã—ãƒãƒ£ãƒãƒ«ã¯ã€é€ä¿¡è€…ã¨å—ä¿¡è€…ãŒåŒæ™‚ã«æº–å‚™ã§ãã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan int)  // ãƒãƒƒãƒ•ã‚¡ãªã—
    
    go func() {
        fmt.Println("é€ä¿¡è€…: é€ä¿¡æº–å‚™å®Œäº†")
        ch <- 42  // å—ä¿¡è€…ãŒæº–å‚™ã§ãã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯
        fmt.Println("é€ä¿¡è€…: é€ä¿¡å®Œäº†")
    }()
    
    time.Sleep(time.Second)
    fmt.Println("å—ä¿¡è€…: å—ä¿¡æº–å‚™å®Œäº†")
    value := <-ch  // é€ä¿¡è€…ãŒé€ä¿¡ã™ã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯
    fmt.Printf("å—ä¿¡è€…: %d ã‚’å—ä¿¡\n", value)
}
```

```mermaid
sequenceDiagram
    participant Sender as é€ä¿¡è€…
    participant Channel as ãƒãƒ£ãƒãƒ«
    participant Receiver as å—ä¿¡è€…
    
    Sender->>Channel: ch <- 42
    Note over Sender: ãƒ–ãƒ­ãƒƒã‚¯...
    
    Note over Receiver: 1ç§’å¾Œ
    Receiver->>Channel: <-ch
    
    Channel->>Receiver: 42
    Note over Sender: ãƒ–ãƒ­ãƒƒã‚¯è§£é™¤
```

### ãƒãƒƒãƒ•ã‚¡ä»˜ããƒãƒ£ãƒãƒ«

ãƒãƒƒãƒ•ã‚¡ä»˜ããƒãƒ£ãƒãƒ«ã¯ã€ãƒãƒƒãƒ•ã‚¡ãŒæº€æ¯ã«ãªã‚‹ã¾ã§é€ä¿¡ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã›ã‚“ã€‚

```go
package main

import "fmt"

func main() {
    ch := make(chan int, 3)  // ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚º 3
    
    // ãƒãƒƒãƒ•ã‚¡ã«ç©ºããŒã‚ã‚Œã°å³åº§ã«é€ä¿¡
    ch <- 1
    ch <- 2
    ch <- 3
    // ch <- 4  // ã“ã“ã§ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆãƒãƒƒãƒ•ã‚¡æº€æ¯ï¼‰
    
    fmt.Println(<-ch)  // 1
    fmt.Println(<-ch)  // 2
    fmt.Println(<-ch)  // 3
    
    // ãƒãƒƒãƒ•ã‚¡ã®é•·ã•ã¨å®¹é‡
    ch2 := make(chan string, 5)
    ch2 <- "a"
    ch2 <- "b"
    
    fmt.Println("é•·ã•:", len(ch2))  // 2
    fmt.Println("å®¹é‡:", cap(ch2))  // 5
}
```

```mermaid
flowchart LR
    subgraph BUFFERED["ãƒãƒƒãƒ•ã‚¡ä»˜ããƒãƒ£ãƒãƒ« (å®¹é‡3)"]
        SENDER["é€ä¿¡è€…"]
        B1["[1]"]
        B2["[2]"]
        B3["[3]"]
        RECEIVER["å—ä¿¡è€…"]
    end
    
    SENDER --> B1
    B1 --> B2
    B2 --> B3
    B3 --> RECEIVER
```

### ãƒãƒ£ãƒãƒ«ã®æ–¹å‘

```go
package main

import "fmt"

// é€ä¿¡å°‚ç”¨ãƒãƒ£ãƒãƒ«
func sender(ch chan<- int) {
    ch <- 42
    // value := <-ch  // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ï¼
}

// å—ä¿¡å°‚ç”¨ãƒãƒ£ãƒãƒ«
func receiver(ch <-chan int) {
    value := <-ch
    fmt.Println(value)
    // ch <- 100  // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ï¼
}

func main() {
    ch := make(chan int)
    
    go sender(ch)
    receiver(ch)
}
```

```mermaid
flowchart TB
    subgraph CHANNEL_DIRECTION["ãƒãƒ£ãƒãƒ«ã®æ–¹å‘"]
        BIDIRECTIONAL["chan T<br/>åŒæ–¹å‘"]
        SEND_ONLY["chan<- T<br/>é€ä¿¡å°‚ç”¨"]
        RECV_ONLY["<-chan T<br/>å—ä¿¡å°‚ç”¨"]
    end
    
    BIDIRECTIONAL --> SEND_ONLY
    BIDIRECTIONAL --> RECV_ONLY
```

### ãƒãƒ£ãƒãƒ«ã®ã‚¯ãƒ­ãƒ¼ã‚º

```go
package main

import "fmt"

func main() {
    ch := make(chan int, 3)
    
    ch <- 1
    ch <- 2
    ch <- 3
    close(ch)  // ãƒãƒ£ãƒãƒ«ã‚’é–‰ã˜ã‚‹
    
    // é–‰ã˜ãŸãƒãƒ£ãƒãƒ«ã‹ã‚‰å—ä¿¡
    for {
        value, ok := <-ch
        if !ok {
            fmt.Println("ãƒãƒ£ãƒãƒ«ãŒé–‰ã˜ã‚‰ã‚Œã¾ã—ãŸ")
            break
        }
        fmt.Println(value)
    }
    
    // range ã§è‡ªå‹•çš„ã«çµ‚äº†ã‚’æ¤œå‡º
    ch2 := make(chan string)
    go func() {
        ch2 <- "Hello"
        ch2 <- "World"
        close(ch2)
    }()
    
    for msg := range ch2 {
        fmt.Println(msg)
    }
}
```

---

## 14.4 selectæ–‡

### selectã¨ã¯

**select**æ–‡ã¯ã€è¤‡æ•°ã®ãƒãƒ£ãƒãƒ«æ“ä½œã‚’åŒæ™‚ã«å¾…æ©Ÿã—ã€æº–å‚™ãŒã§ããŸã‚‚ã®ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚switchã«ä¼¼ãŸæ§‹æ–‡ã§ã™ãŒã€ãƒãƒ£ãƒãƒ«æ“ä½œã«ç‰¹åŒ–ã—ã¦ã„ã¾ã™ã€‚

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    go func() {
        time.Sleep(100 * time.Millisecond)
        ch1 <- "from ch1"
    }()
    
    go func() {
        time.Sleep(200 * time.Millisecond)
        ch2 <- "from ch2"
    }()
    
    for i := 0; i < 2; i++ {
        select {
        case msg := <-ch1:
            fmt.Println(msg)
        case msg := <-ch2:
            fmt.Println(msg)
        }
    }
}
```

```mermaid
flowchart TB
    subgraph SELECT["select æ–‡ã®å‹•ä½œ"]
        SELECT_BLOCK["select"]
        
        CASE1["case <-ch1"]
        CASE2["case <-ch2"]
        CASE3["case ch3 <- value"]
        DEFAULT["default"]
        
        SELECT_BLOCK --> CASE1
        SELECT_BLOCK --> CASE2
        SELECT_BLOCK --> CASE3
        SELECT_BLOCK --> DEFAULT
    end
    
    NOTE["æœ€åˆã«æº–å‚™ãŒã§ããŸ<br/>caseãŒå®Ÿè¡Œã•ã‚Œã‚‹"]
```

### ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan string)
    
    go func() {
        time.Sleep(2 * time.Second)
        ch <- "result"
    }()
    
    select {
    case result := <-ch:
        fmt.Println("çµæœ:", result)
    case <-time.After(1 * time.Second):
        fmt.Println("ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ")
    }
}
```

### éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°æ“ä½œï¼ˆdefaultï¼‰

```go
package main

import "fmt"

func main() {
    ch := make(chan int, 1)
    
    // éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°é€ä¿¡
    select {
    case ch <- 42:
        fmt.Println("é€ä¿¡æˆåŠŸ")
    default:
        fmt.Println("ãƒãƒ£ãƒãƒ«ãŒæº€æ¯")
    }
    
    // éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°å—ä¿¡
    select {
    case value := <-ch:
        fmt.Printf("å—ä¿¡: %d\n", value)
    default:
        fmt.Println("ãƒ‡ãƒ¼ã‚¿ãªã—")
    }
}
```

### ãƒ«ãƒ¼ãƒ—å†…ã§ã®select

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    tick := time.Tick(500 * time.Millisecond)
    done := time.After(2 * time.Second)
    
    for {
        select {
        case <-done:
            fmt.Println("çµ‚äº†")
            return
        case t := <-tick:
            fmt.Println("Tick at", t)
        }
    }
}
```

### è¤‡æ•°ã®ã‚±ãƒ¼ã‚¹ãŒæº–å‚™ã§ããŸå ´åˆ

```go
package main

import "fmt"

func main() {
    ch1 := make(chan int, 1)
    ch2 := make(chan int, 1)
    
    ch1 <- 1
    ch2 <- 2
    
    // ä¸¡æ–¹æº–å‚™ã§ãã¦ã„ã‚‹å ´åˆã€ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠã•ã‚Œã‚‹
    for i := 0; i < 10; i++ {
        ch1 <- 1
        ch2 <- 2
        
        select {
        case <-ch1:
            fmt.Println("ch1")
        case <-ch2:
            fmt.Println("ch2")
        }
    }
}
```

---

## 14.5 ä¸¦è¡Œãƒ‘ã‚¿ãƒ¼ãƒ³

### ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

```go
package main

import "fmt"

func generator(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}

func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}

func main() {
    // ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’æ§‹ç¯‰
    nums := generator(1, 2, 3, 4, 5)
    squared := square(nums)
    
    for result := range squared {
        fmt.Println(result)  // 1, 4, 9, 16, 25
    }
}
```

```mermaid
flowchart LR
    subgraph PIPELINE["ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³"]
        GEN["generator<br/>[1,2,3,4,5]"]
        CH1["chan"]
        SQ["square<br/>n*n"]
        CH2["chan"]
        OUT["å‡ºåŠ›<br/>[1,4,9,16,25]"]
    end
    
    GEN --> CH1 --> SQ --> CH2 --> OUT
```

### ãƒ•ã‚¡ãƒ³ã‚¢ã‚¦ãƒˆãƒ»ãƒ•ã‚¡ãƒ³ã‚¤ãƒ³

```go
package main

import (
    "fmt"
    "sync"
)

func fanOut(in <-chan int, workers int) []<-chan int {
    channels := make([]<-chan int, workers)
    
    for i := 0; i < workers; i++ {
        channels[i] = worker(in, i)
    }
    
    return channels
}

func worker(in <-chan int, id int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            fmt.Printf("Worker %d processing %d\n", id, n)
            out <- n * n
        }
        close(out)
    }()
    return out
}

func fanIn(channels ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    out := make(chan int)
    
    output := func(ch <-chan int) {
        defer wg.Done()
        for n := range ch {
            out <- n
        }
    }
    
    wg.Add(len(channels))
    for _, ch := range channels {
        go output(ch)
    }
    
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}

func main() {
    in := make(chan int)
    
    go func() {
        for i := 1; i <= 10; i++ {
            in <- i
        }
        close(in)
    }()
    
    // ãƒ•ã‚¡ãƒ³ã‚¢ã‚¦ãƒˆ: 3ã¤ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ã«åˆ†æ•£
    channels := fanOut(in, 3)
    
    // ãƒ•ã‚¡ãƒ³ã‚¤ãƒ³: çµæœã‚’é›†ç´„
    for result := range fanIn(channels...) {
        fmt.Println("Result:", result)
    }
}
```

```mermaid
flowchart TB
    subgraph FAN_OUT_IN["ãƒ•ã‚¡ãƒ³ã‚¢ã‚¦ãƒˆãƒ»ãƒ•ã‚¡ãƒ³ã‚¤ãƒ³"]
        INPUT["å…¥åŠ›"]
        
        W1["Worker 1"]
        W2["Worker 2"]
        W3["Worker 3"]
        
        OUTPUT["å‡ºåŠ›"]
    end
    
    INPUT --> W1
    INPUT --> W2
    INPUT --> W3
    
    W1 --> OUTPUT
    W2 --> OUTPUT
    W3 --> OUTPUT
```

### ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ¼ãƒ«

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type Job struct {
    ID   int
    Data string
}

type Result struct {
    Job    Job
    Output string
}

func worker(id int, jobs <-chan Job, results chan<- Result, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for job := range jobs {
        fmt.Printf("Worker %d started job %d\n", id, job.ID)
        time.Sleep(100 * time.Millisecond)  // å‡¦ç†ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
        
        results <- Result{
            Job:    job,
            Output: fmt.Sprintf("Processed: %s", job.Data),
        }
        fmt.Printf("Worker %d finished job %d\n", id, job.ID)
    }
}

func main() {
    jobs := make(chan Job, 100)
    results := make(chan Result, 100)
    
    var wg sync.WaitGroup
    
    // ãƒ¯ãƒ¼ã‚«ãƒ¼ã‚’èµ·å‹•
    numWorkers := 3
    for w := 1; w <= numWorkers; w++ {
        wg.Add(1)
        go worker(w, jobs, results, &wg)
    }
    
    // ã‚¸ãƒ§ãƒ–ã‚’æŠ•å…¥
    go func() {
        for i := 1; i <= 10; i++ {
            jobs <- Job{ID: i, Data: fmt.Sprintf("job-%d", i)}
        }
        close(jobs)
    }()
    
    // ãƒ¯ãƒ¼ã‚«ãƒ¼ã®å®Œäº†ã‚’å¾…ã£ã¦ã‹ã‚‰ results ã‚’é–‰ã˜ã‚‹
    go func() {
        wg.Wait()
        close(results)
    }()
    
    // çµæœã‚’åé›†
    for result := range results {
        fmt.Printf("Result: %s\n", result.Output)
    }
}
```

### ã‚­ãƒ£ãƒ³ã‚»ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆcontextï¼‰

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func worker(ctx context.Context, id int) {
    for {
        select {
        case <-ctx.Done():
            fmt.Printf("Worker %d: ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ\n", id)
            return
        default:
            fmt.Printf("Worker %d: ä½œæ¥­ä¸­...\n", id)
            time.Sleep(500 * time.Millisecond)
        }
    }
}

func main() {
    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    
    go worker(ctx, 1)
    go worker(ctx, 2)
    
    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¾ã§å¾…ã¤
    <-ctx.Done()
    fmt.Println("ãƒ¡ã‚¤ãƒ³: ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒçµ‚äº†ã—ã¾ã—ãŸ")
    time.Sleep(100 * time.Millisecond)  // ãƒ¯ãƒ¼ã‚«ãƒ¼ã®çµ‚äº†ã‚’å¾…ã¤
}
```

```mermaid
flowchart TB
    subgraph CONTEXT["context ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸"]
        BG["context.Background()<br/>ãƒ«ãƒ¼ãƒˆã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ"]
        TODO["context.TODO()<br/>TODOç”¨"]
        
        WITH_CANCEL["WithCancel<br/>æ‰‹å‹•ã‚­ãƒ£ãƒ³ã‚»ãƒ«"]
        WITH_TIMEOUT["WithTimeout<br/>ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ"]
        WITH_DEADLINE["WithDeadline<br/>æœŸé™æŒ‡å®š"]
        WITH_VALUE["WithValue<br/>å€¤ã‚’ä¼æ’­"]
    end
    
    BG --> WITH_CANCEL
    BG --> WITH_TIMEOUT
    BG --> WITH_DEADLINE
    BG --> WITH_VALUE
```

---

## 14.6 M:N ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°

### Goroutineã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ã®G-M-Pãƒ¢ãƒ‡ãƒ«

Goãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã¯ã€**G**ï¼ˆGoroutineï¼‰ã€**M**ï¼ˆMachine/OSã‚¹ãƒ¬ãƒƒãƒ‰ï¼‰ã€**P**ï¼ˆProcessorï¼‰ã®3ã¤ã®æ¦‚å¿µã§ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã‚’è¡Œã„ã¾ã™ã€‚

```mermaid
flowchart TB
    subgraph GMP_MODEL["G-M-P ãƒ¢ãƒ‡ãƒ«"]
        subgraph G["G (Goroutine)"]
            G1["G1"]
            G2["G2"]
            G3["G3"]
            G4["G4"]
        end
        
        subgraph P["P (Processor)"]
            P1["P1"]
            P2["P2"]
        end
        
        subgraph M["M (Machine/OS Thread)"]
            M1["M1"]
            M2["M2"]
        end
        
        OS["OS ã‚«ãƒ¼ãƒãƒ«"]
    end
    
    G1 --> P1
    G2 --> P1
    G3 --> P2
    G4 --> P2
    
    P1 --> M1
    P2 --> M2
    
    M1 --> OS
    M2 --> OS
```

### å„ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®å½¹å‰²

| ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ | èª¬æ˜ |
|----------------|------|
| **G (Goroutine)** | å®Ÿè¡Œã™ã‚‹ã‚³ãƒ¼ãƒ‰ã€ã‚¹ã‚¿ãƒƒã‚¯ã€çŠ¶æ…‹ã‚’æŒã¤è»½é‡ã‚¹ãƒ¬ãƒƒãƒ‰ |
| **M (Machine)** | OSã‚¹ãƒ¬ãƒƒãƒ‰ã€‚Gã‚’å®Ÿéš›ã«å®Ÿè¡Œã™ã‚‹ |
| **P (Processor)** | ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã€‚ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ¥ãƒ¼ã‚’æŒã¤ |

```mermaid
flowchart LR
    subgraph PROCESSOR["P (Processor)"]
        LRQ["ãƒ­ãƒ¼ã‚«ãƒ«å®Ÿè¡Œã‚­ãƒ¥ãƒ¼"]
        CURRENT["ç¾åœ¨å®Ÿè¡Œä¸­ã®G"]
    end
    
    subgraph GLOBAL["ã‚°ãƒ­ãƒ¼ãƒãƒ«"]
        GRQ["ã‚°ãƒ­ãƒ¼ãƒãƒ«å®Ÿè¡Œã‚­ãƒ¥ãƒ¼"]
    end
    
    GRQ -->|"ã‚­ãƒ¥ãƒ¼ãŒç©ºã®æ™‚"| LRQ
    LRQ --> CURRENT
```

### GOMAXPROCS

`GOMAXPROCS`ã¯ã€åŒæ™‚ã«å®Ÿè¡Œã§ãã‚‹Pã®æ•°ï¼ˆâ‰’ä½¿ç”¨ã™ã‚‹CPUã‚³ã‚¢æ•°ï¼‰ã‚’è¨­å®šã—ã¾ã™ã€‚

```go
package main

import (
    "fmt"
    "runtime"
)

func main() {
    // ç¾åœ¨ã® GOMAXPROCS ã‚’å–å¾—
    n := runtime.GOMAXPROCS(0)
    fmt.Println("Current GOMAXPROCS:", n)
    
    // åˆ©ç”¨å¯èƒ½ãª CPU æ•°
    numCPU := runtime.NumCPU()
    fmt.Println("Number of CPUs:", numCPU)
    
    // GOMAXPROCS ã‚’è¨­å®š
    runtime.GOMAXPROCS(4)
    
    // ç¾åœ¨ã® goroutine æ•°
    fmt.Println("Number of goroutines:", runtime.NumGoroutine())
}
```

### Work Stealing

Pã®ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ¥ãƒ¼ãŒç©ºã«ãªã‚‹ã¨ã€ä»–ã®Pã‹ã‚‰Gã‚’ã€Œç›—ã‚€ã€ã“ã¨ã§è² è·åˆ†æ•£ã‚’è¡Œã„ã¾ã™ã€‚

```mermaid
sequenceDiagram
    participant P1 as P1 (å¿™ã—ã„)
    participant P2 as P2 (æš‡)
    participant GRQ as ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚­ãƒ¥ãƒ¼
    
    Note over P1: ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ¥ãƒ¼ã«<br/>G ãŒè¤‡æ•°
    Note over P2: ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ¥ãƒ¼ãŒç©º
    
    P2->>GRQ: ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚­ãƒ¥ãƒ¼ã‚’ç¢ºèª
    Note over GRQ: ç©º
    
    P2->>P1: Work Stealing!
    P1-->>P2: G ã®åŠåˆ†ã‚’æ¸¡ã™
    
    Note over P2: å‡¦ç†ã‚’å†é–‹
```

### Goroutineã®çŠ¶æ…‹é·ç§»

```mermaid
stateDiagram-v2
    [*] --> Runnable: go func()
    Runnable --> Running: ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚Œã‚‹
    Running --> Runnable: ãƒ—ãƒªã‚¨ãƒ³ãƒ—ã‚·ãƒ§ãƒ³
    Running --> Waiting: I/O, ãƒãƒ£ãƒãƒ«, syscall
    Waiting --> Runnable: å®Œäº†
    Running --> Dead: çµ‚äº†
    Dead --> [*]
```

### ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒãƒ¼ãƒªãƒ³ã‚°

```go
// ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ä¸­ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°
// MãŒãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°I/Oã§ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã¨ã€
// Pã¯åˆ¥ã®Mã«ã‚¢ã‚¿ãƒƒãƒã•ã‚Œã‚‹

package main

import (
    "fmt"
    "os"
    "time"
)

func blockingIO() {
    // ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«
    data := make([]byte, 1024)
    os.Stdin.Read(data)  // ã“ã®é–“ã€Mã¯ãƒ–ãƒ­ãƒƒã‚¯
    fmt.Println("Read:", string(data))
}

func asyncWork() {
    for {
        fmt.Println("Async work...")
        time.Sleep(500 * time.Millisecond)
    }
}

func main() {
    go asyncWork()  // ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°IOä¸­ã‚‚å‹•ãç¶šã‘ã‚‹
    blockingIO()
}
```

---

## 14.7 åŒæœŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–

### sync.Mutex

```go
package main

import (
    "fmt"
    "sync"
)

type Counter struct {
    mu    sync.Mutex
    value int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

func (c *Counter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

func main() {
    counter := &Counter{}
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }
    
    wg.Wait()
    fmt.Println("Counter:", counter.Value())  // 1000
}
```

### sync.RWMutex

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type Cache struct {
    mu   sync.RWMutex
    data map[string]string
}

func (c *Cache) Get(key string) (string, bool) {
    c.mu.RLock()  // èª­ã¿å–ã‚Šãƒ­ãƒƒã‚¯
    defer c.mu.RUnlock()
    value, ok := c.data[key]
    return value, ok
}

func (c *Cache) Set(key, value string) {
    c.mu.Lock()  // æ›¸ãè¾¼ã¿ãƒ­ãƒƒã‚¯
    defer c.mu.Unlock()
    c.data[key] = value
}

func main() {
    cache := &Cache{data: make(map[string]string)}
    
    // æ›¸ãè¾¼ã¿
    go func() {
        for i := 0; i < 10; i++ {
            cache.Set(fmt.Sprintf("key%d", i), fmt.Sprintf("value%d", i))
            time.Sleep(10 * time.Millisecond)
        }
    }()
    
    // èª­ã¿å–ã‚Šï¼ˆè¤‡æ•°åŒæ™‚å¯èƒ½ï¼‰
    var wg sync.WaitGroup
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for j := 0; j < 20; j++ {
                if val, ok := cache.Get("key5"); ok {
                    fmt.Printf("Reader %d: %s\n", id, val)
                }
                time.Sleep(5 * time.Millisecond)
            }
        }(i)
    }
    
    wg.Wait()
}
```

### sync.Once

```go
package main

import (
    "fmt"
    "sync"
)

var once sync.Once
var instance *Singleton

type Singleton struct {
    value string
}

func GetInstance() *Singleton {
    once.Do(func() {
        fmt.Println("Creating singleton...")
        instance = &Singleton{value: "I am the one"}
    })
    return instance
}

func main() {
    var wg sync.WaitGroup
    
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            s := GetInstance()
            fmt.Println(s.value)
        }()
    }
    
    wg.Wait()
    // "Creating singleton..." ã¯1å›ã ã‘è¡¨ç¤ºã•ã‚Œã‚‹
}
```

### sync.Cond

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    var mu sync.Mutex
    cond := sync.NewCond(&mu)
    
    ready := false
    
    // å¾…æ©Ÿã™ã‚‹ goroutine
    go func() {
        mu.Lock()
        for !ready {
            cond.Wait()  // æ¡ä»¶ãŒæº€ãŸã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿ
        }
        fmt.Println("Worker: æ¡ä»¶ãŒæº€ãŸã•ã‚Œã¾ã—ãŸ!")
        mu.Unlock()
    }()
    
    // æ¡ä»¶ã‚’è¨­å®šã™ã‚‹ goroutine
    time.Sleep(time.Second)
    mu.Lock()
    ready = true
    cond.Signal()  // 1ã¤ã®å¾…æ©Ÿè€…ã«é€šçŸ¥
    // cond.Broadcast()  // ã™ã¹ã¦ã®å¾…æ©Ÿè€…ã«é€šçŸ¥
    mu.Unlock()
    
    time.Sleep(100 * time.Millisecond)
}
```

### sync/atomic

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

func main() {
    var counter int64 = 0
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            atomic.AddInt64(&counter, 1)  // ã‚¢ãƒˆãƒŸãƒƒã‚¯ã«åŠ ç®—
        }()
    }
    
    wg.Wait()
    fmt.Println("Counter:", atomic.LoadInt64(&counter))  // 1000
}
```

---

## 14.8 ã¾ã¨ã‚

ã“ã®ç« ã§ã¯ã€Goã®ä¸¦è¡Œå‡¦ç†ã«ã¤ã„ã¦è©³ã—ãå­¦ã³ã¾ã—ãŸã€‚

```mermaid
mindmap
    root((ç¬¬14ç« ã®ã¾ã¨ã‚))
        Goroutine
            è»½é‡ã‚¹ãƒ¬ãƒƒãƒ‰
            go ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
            WaitGroup
        ãƒãƒ£ãƒãƒ«
            ãƒãƒƒãƒ•ã‚¡ãªã—/ã‚ã‚Š
            é€å—ä¿¡
            close
        select
            è¤‡æ•°ãƒãƒ£ãƒãƒ«å¾…æ©Ÿ
            ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
            default
        ãƒ‘ã‚¿ãƒ¼ãƒ³
            ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
            ãƒ•ã‚¡ãƒ³ã‚¢ã‚¦ãƒˆ/ã‚¤ãƒ³
            ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ¼ãƒ«
            context
        G-M-P
            Goroutine
            Machine
            Processor
            Work Stealing
```

### é‡è¦ãªãƒã‚¤ãƒ³ãƒˆ

#### 1. Goroutineã¯è»½é‡ã§å¤§é‡ã«ç”Ÿæˆå¯èƒ½

Goroutineã¯åˆæœŸã‚¹ã‚¿ãƒƒã‚¯2KBã¨è»½é‡ã§ã€æ•°ç™¾ä¸‡åŒæ™‚å®Ÿè¡Œã‚‚å¯èƒ½ã§ã™ã€‚`go`ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§ç°¡å˜ã«èµ·å‹•ã§ãã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãŒåŠ¹ç‡çš„ã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã—ã¾ã™ã€‚

#### 2. ãƒãƒ£ãƒãƒ«ã¯Goroutineé–“ã®å®‰å…¨ãªé€šä¿¡æ‰‹æ®µ

ãƒãƒ£ãƒãƒ«ã‚’ä½¿ã†ã“ã¨ã§ã€ãƒ­ãƒƒã‚¯ãªã—ã§å®‰å…¨ã«ãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘æ¸¡ã›ã¾ã™ã€‚ãƒãƒƒãƒ•ã‚¡ãªã—ãƒãƒ£ãƒãƒ«ã¯åŒæœŸã«ã‚‚ä½¿ãˆã¾ã™ã€‚

#### 3. selectã§è¤‡æ•°ãƒãƒ£ãƒãƒ«ã‚’åŠ¹ç‡çš„ã«å‡¦ç†

selectæ–‡ã§è¤‡æ•°ã®ãƒãƒ£ãƒãƒ«æ“ä½œã‚’åŒæ™‚ã«å¾…æ©Ÿã§ãã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚„éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°æ“ä½œã‚‚ç°¡å˜ã«å®Ÿè£…ã§ãã¾ã™ã€‚

#### 4. G-M-Pãƒ¢ãƒ‡ãƒ«ã§M:Nã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã‚’å®Ÿç¾

Goãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã¯OSã‚¹ãƒ¬ãƒƒãƒ‰ã‚ˆã‚Šå¤šãã®Goroutineã‚’åŠ¹ç‡çš„ã«å®Ÿè¡Œã—ã¾ã™ã€‚Work Stealingã«ã‚ˆã‚Šè² è·ãŒå‡ç­‰ã«åˆ†æ•£ã•ã‚Œã¾ã™ã€‚

---

## ğŸ“ ç·´ç¿’å•é¡Œ

1. **Goroutineã¨ã‚¹ãƒ¬ãƒƒãƒ‰ã®é•ã„ã‚’èª¬æ˜ã—ã¦ãã ã•ã„ã€‚**
   
   ãƒ’ãƒ³ãƒˆï¼šã‚¹ã‚¿ãƒƒã‚¯ã‚µã‚¤ã‚ºã€ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã€ç”Ÿæˆã‚³ã‚¹ãƒˆã«ã¤ã„ã¦è€ƒãˆã¦ãã ã•ã„ã€‚

2. **ãƒãƒƒãƒ•ã‚¡ãªã—ãƒãƒ£ãƒãƒ«ã¨ãƒãƒƒãƒ•ã‚¡ä»˜ããƒãƒ£ãƒãƒ«ã®å‹•ä½œã®é•ã„ã‚’èª¬æ˜ã—ã¦ãã ã•ã„ã€‚**
   
   ãƒ’ãƒ³ãƒˆï¼šé€ä¿¡ãƒ»å—ä¿¡æ™‚ã®ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°å‹•ä½œã«ã¤ã„ã¦è€ƒãˆã¦ãã ã•ã„ã€‚

3. **ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã®å•é¡Œç‚¹ã‚’æŒ‡æ‘˜ã—ã€ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚**

   ```go
   func main() {
       ch := make(chan int)
       
       go func() {
           for i := 0; i < 5; i++ {
               ch <- i
           }
       }()
       
       for v := range ch {
           fmt.Println(v)
       }
   }
   ```
   
   ãƒ’ãƒ³ãƒˆï¼šãƒãƒ£ãƒãƒ«ã®ã‚¯ãƒ­ãƒ¼ã‚ºã«ã¤ã„ã¦è€ƒãˆã¦ãã ã•ã„ã€‚

4. **ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ¼ãƒ«ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã£ã¦ã€10å€‹ã®URLã‚’3ã¤ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ã§ä¸¦è¡Œå‡¦ç†ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦ãã ã•ã„ã€‚**
   
   ãƒ’ãƒ³ãƒˆï¼šã‚¸ãƒ§ãƒ–ãƒãƒ£ãƒãƒ«ã¨çµæœãƒãƒ£ãƒãƒ«ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚

5. **G-M-Pãƒ¢ãƒ‡ãƒ«ã«ãŠã‘ã‚‹ã€ŒWork Stealingã€ã®ä»•çµ„ã¿ã¨ã€ãã‚ŒãŒã‚‚ãŸã‚‰ã™åˆ©ç‚¹ã‚’èª¬æ˜ã—ã¦ãã ã•ã„ã€‚**
   
   ãƒ’ãƒ³ãƒˆï¼šè² è·åˆ†æ•£ã¨ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ã«ã¤ã„ã¦è€ƒãˆã¦ãã ã•ã„ã€‚

---

## ğŸ”— æ¬¡ã®ç« ã¸

[ç¬¬15ç« : C# / .NET](./15-csharp.md) ã§ã¯ã€C#ã®Taskã€async/awaitã€SynchronizationContextã€ValueTaskã«ã¤ã„ã¦è©³ã—ãå­¦ã³ã¾ã™ã€‚

---

[â† ç›®æ¬¡ã«æˆ»ã‚‹](../index.md) | [â† å‰ç« : Rust](./13-rust.md)

